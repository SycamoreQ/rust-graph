use std::sync::Arc;
use candle::core::{Tensor , Device , Dtype};
use serde::json;
use std::collections::{HashMap , HashSet}; 
use rayon::prelude::*;
use nalgebra::{sqrt};

pub type NodeID  = u64;
pub type EdgeID = u64;
pub type GraphID = u64 ; 
pub type SubgraphID = u64;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EdgeDirection {
    Incoming,
    Outgoing,
    Both,
}


#[derive(Debug , Clone , PartialEq , HashMap , Eq)]
pub struct Node{
    pub id : NodeID,
    pub nodeType: Option<Tensor>,
    pub attributes : HashMap<String , AttributeValue>,
    pub features: Option<Tensor>,
}

impl Node {
    pub fn new(id : NodeID , node_type : Option<Tensor>) {
        Self(
            id ,
            node_type ,
            HashMap::new(),
            None,
        )
    }
    
    pub fn with_features(mut self, features: Tensor) -> Self {
        self.features = Some(features);
        self
    }

    pub fn with_attribute<V: Into<AttributeValue>>(mut self, key: String, value: V) -> Self {
        self.attributes.insert(key, value.into());
        self
    }

    pub fn feature_dim(&self) -> Option<usize> {
        self.features.as_ref().map(|f| f.shape()[f.shape().len() - 1])
    }
}

#[derive(Debug , Clone , PartialEq , HashMap , Eq)]
pub struct Edge{
    pub id: EdgeID,
    pub src: NodeID,
    pub dst: NodeID,
    pub EdgeType: Option<Tensor>,
    pub features: Option<Tensor>,
    pub weight: f32 , 
    pub attributes: HashMap<String , AttributeValue>,
}

impl Edge{ 
    pub fn new(id : EdgeID , src: NodeID , dst: NodeID ,  edge_type: Option<Tensor>){
        Self(
            id , 
            src ,
            dst ,
            edge_type,
            None,
            1.0,
            HashMap::new(),
        )   
    }
    
    pub fn with_features(mut self, features: Tensor) -> Self {
        self.features = Some(features);
        self
    }

    pub fn with_attribute<V: Into<AttributeValue>>(mut self, key: String, value: V) -> Self {
        self.attributes.insert(key, value.into());
        self
    }
    
    pub fn with_weight(mut self, weight: f32) -> Self {
        self.weight = weight;
        self
    }

    pub fn feature_dim(&self) -> Option<usize> {
        self.features.as_ref().map(|f| f.shape()[f.shape().len() - 1])
    }
    
    pub fn reverse(&self) -> Self {
        Edge {
            id: self.id,
            source: self.target,
            target: self.source,
            edge_type: self.edge_type.clone(),
            features: self.features.clone(),
            weight: self.weight,
            attributes: self.attributes.clone(),
        }
    }
}

#[derive(Debug, Clone)]
pub enum AttributeValue {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    Vector(Vec<f32>),
    Tensor(Tensor),
}

impl From<String> for AttributeValue {
    fn from(s: String) -> Self { AttributeValue::String(s) }
}
impl From<i64> for AttributeValue {
    fn from(i: i64) -> Self { AttributeValue::Integer(i) }
}
impl From<f64> for AttributeValue {
    fn from(f: f64) -> Self { AttributeValue::Float(f) }
}
impl From<bool> for AttributeValue {
    fn from(b: bool) -> Self { AttributeValue::Boolean(b) }
}
impl From<Vec<f32>> for AttributeValue {
    fn from(v: Vec<f32>) -> Self { AttributeValue::Vector(v) }
}

/// Error types for graph operations
#[derive(Debug)]
pub enum GraphError {
    NodeNotFound(NodeId),
    EdgeNotFound(EdgeId),
    InvalidEdge(String),
    FeatureMismatch(String),
    ConversionError(String),
    TensorError(TensorError),
}

impl From<TensorError> for GraphError {
    fn from(e: TensorError) -> Self {
        GraphError::TensorError(e)
    }
}

impl std::fmt::Display for GraphError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GraphError::NodeNotFound(id) => write!(f, "Node not found: {}", id),
            GraphError::EdgeNotFound(id) => write!(f, "Edge not found: {}", id),
            GraphError::InvalidEdge(msg) => write!(f, "Invalid edge: {}", msg),
            GraphError::FeatureMismatch(msg) => write!(f, "Feature mismatch: {}", msg),
            GraphError::ConversionError(msg) => write!(f, "Conversion error: {}", msg),
            GraphError::TensorError(e) => write!(f, "Tensor error: {}", e),
        }
    }
}

pub trait GraphOps{
    pub fn add_node(&self , node : Node) -> Result<() , GraphError>;
    pub fn add_edge(&self , edge : Edge) -> Result<() , GraphError>;
    pub fn remove_node(&self , node : NodeId) -> Result<() , GraphError>;
    pub fn remove_edge(&self , edge : EdgeId) -> Result<() , GraphError>;
    pub fn update_node(&self , node : NodeId , new_node : Node) -> Result<() , GraphError>;
    pub fn update_edge(&self , edge : EdgeId , new_edge : Edge) -> Result<() , GraphError>;
    pub fn get_node(&self , node : NodeId) -> Result<Node , GraphError>;
    pub fn get_edge(&self , edge : EdgeId) -> Result<Edge , GraphError>;
    pub fn neighbors(&self , node : NodeId , direction: EdgeDirection) -> Result<Vec<NodeId> , GraphError>;
    pub fn node_count(&self) -> Result<usize , GraphError>;
    pub fn edge_count(&self) -> Result<usize , GraphError>;
    pub fn to_undirected(&mut self) -> Result<Self , GraphError>;
}

#[derive(Serialize , Debug)]
pub struct Graph{
    pub id : GraphID,
    pub nodes: HashMap<NodeID , Node> ,
    pub edges: HashMap<EdgeID , Edge> ,
    pub adjacency_list: HashMap<NodeID , Vec<EdgeID>> ,
    pub reverse_adjacency: HashMap<NodeID , Vec<EdgeID>> ,
    pub edge_list: HashMap<EdgeID , Vec<EdgeID>>,
    pub node_list: Vec<NodeId>,
    pub edge_list: Vec<EdgeId>,
    pub attributes: HashMap<String, AttributeValue>,
    pub is_directed: bool,
    pub next_node_id: NodeId,
    pub next_edge_id: EdgeId,
}

impl Graph{
    
    pub fn new(id: GraphId, is_directed: bool) -> Self {
        Self {
            id,
            nodes: HashMap::new(),
            edges: HashMap::new(),
            adjacency_list: HashMap::new(),
            reverse_adjacency: HashMap::new(),
            node_types: HashMap::new(),
            edge_types: HashMap::new(),
            is_directed,
            attributes: HashMap::new(),
            next_node_id: 0,
            next_edge_id: 0,
        }
    }
    
    pub fn directed() -> Self {
        Self::new(GraphId::new(), true)
    }
    
    pub fn undirected() -> Self {
        Self::new(GraphId::new(), false)
    }
    
    pub fn degree(&self, node_id: NodeId, direction: EdgeDirection) -> usize {
          match direction {
              EdgeDirection::Outgoing => self.adjacency_list.get(&node_id).map_or(0, |v| v.len()),
              EdgeDirection::Incoming => self.reverse_adjacency.get(&node_id).map_or(0, |v| v.len()),
              EdgeDirection::Both => {
                  let out_degree = self.adjacency_list.get(&node_id).map_or(0, |v| v.len());
                  let in_degree = self.reverse_adjacency.get(&node_id).map_or(0, |v| v.len());
                  if self.is_directed {
                      out_degree + in_degree
                  } else {
                      out_degree // For undirected graphs, both lists are the same
                  }
              }
          }
      }
      
    pub fn density(&self , node_id: NodeID , edge_id: EdgeID ,  direction: EdgeDirection) -> usize{
        match direction{
            EdgeDirection::Outgoing => {
                let m = self.adjacency_list.get(&node_id).map_or(0, |v| v.len());
                let n = self.adjacency_list.len();
                
                let D = (2*m)/(n)*(n-1);
                D as f64 / (n*(n-1) as f64)
            }
            
            EdgeDirection::Incoming => {
                let m = self.reverse_adjacency.get(&node_id).map_or(0, |v| v.len());
                let n = self.adjacency_list.len();
                
                let D = (2*m)/(n)*(n-1);
                D as f64 / (n*(n-1) as f64)
            }
            
            EdgeDirection::Both => {
                let m = self.adjacency_list.get(&node_id).map_or(0, |v| v.len());
                let n = self.adjacency_list.len();
                
                if self.is_directed{
                    let m = self.reverse_adjacency.get(&node_id).map_or(0, |v| v.len());
                    let n = self.adjacency_list.len();
                    
                    let D = (m)/(n)*(n-1);
                    D as f64 / (n*(n-1) as f64)
                }else{
                    let D = (2*m)/(n)*(n-1);
                    D as f64 / (n*(n-1) as f64)
                }
            }
        }
    }
    
    pub fn k_hop(&self , node_id: NodeID , k:usize) -> HashSet<NodeID>{
        let current = HashSet::new();
        let mut visited = HashSet::new();
        let mut queue = VecDeque::new();
        queue.push_back(node_id);
        visited.insert(node_id);
        
        for _ in 0..k {
            let mut next = HashSet::new();
            while let Some(node) = queue.pop_front() {
                for neighbor in self.adjacency_list.get(&node).unwrap_or(&vec![]) {
                    if !visited.contains(neighbor) {
                        next.insert(*neighbor);
                    }
                }
            }
            queue.extend(next.difference(&visited));
            visited.extend(next);
        }
        
        visited
    }
    
    pub fn subgraph(&self, node_ids: &[NodeId]) -> Result<Graph, GraphError> {
        let mut sub_graph = Graph::new(self.id + 1, self.is_directed);
        let node_set: HashSet<NodeId> = node_ids.iter().cloned().collect();

        // Add nodes
        for &node_id in node_ids {
            if let Some(node) = self.nodes.get(&node_id) {
                sub_graph.add_node(node.clone())?;
            }
        }

        // Add edges between included nodes
        for edge in self.edges.values() {
            if node_set.contains(&edge.source) && node_set.contains(&edge.target) {
                sub_graph.add_edge(edge.clone())?;
            }
        }

        Ok(sub_graph)
    }
    
    pub fn to_coo(&self) -> Result<(Tensor, Tensor, Option<Tensor>), GraphError> {
         let num_edges = if self.is_directed { 
             self.edges.len() 
         } else { 
             self.edges.len() * 2 // Each undirected edge becomes two directed edges
         };
 
         let mut edge_indices = Vec::with_capacity(num_edges * 2);
         let mut edge_weights = Vec::with_capacity(num_edges);
         let mut edge_features = Vec::new();
         
         let node_to_idx: HashMap<NodeId, usize> = self.nodes.keys()
             .enumerate()
             .map(|(i, &id)| (id, i))
             .collect();
 
         for edge in self.edges.values() {
             let src_idx = *node_to_idx.get(&edge.source)
                 .ok_or(GraphError::NodeNotFound(edge.source))?;
             let tgt_idx = *node_to_idx.get(&edge.target)
                 .ok_or(GraphError::NodeNotFound(edge.target))?;
 
             edge_indices.extend_from_slice(&[src_idx, tgt_idx]);
             edge_weights.push(edge.weight);
 
             if let Some(ref features) = edge.features {
                 edge_features.push(features.clone());
             }
 
             // For undirected graphs, add reverse edge
             if !self.is_directed && edge.source != edge.target {
                 edge_indices.extend_from_slice(&[tgt_idx, src_idx]);
                 edge_weights.push(edge.weight);
                 if let Some(ref features) = edge.features {
                     edge_features.push(features.clone());
                 }
             }
         }
 
         let edge_index = Tensor::from_data(edge_indices, &[2, num_edges])?;
         let edge_weight = Tensor::from_data(edge_weights, &[num_edges])?;
         
         let edge_attr = if !edge_features.is_empty() {
             // Stack edge features - this would need proper tensor stacking implementation
             Some(edge_features[0].clone()) // Simplified for demo
         } else {
             None
         };
 
         Ok((edge_index, edge_weight, edge_attr))
     }
     
    

    pub fn Laplacian(&self , normalized: bool) -> Result<Tensor , GraphError>{
        let (edge_index , edge_weight , _ ) = self.to_coo()?;
        let num_nodes = self.nodes.len();
        
        let mut adjacency_matrix = vec![0.0f32; num_nodes * num_nodes];
        let edge_indices = edge_index.to_vec()?;
        let weights = edge_weight.to_vec()?;
        
        for (i , chunk) in edge_indices.chunks(2).enumerate(){
            let src = chunk[0];
            let tgt = chunk[1];
            adjacency_matrix[src * num_nodes + tgt] += weights[i];
            adjacency_matrix[tgt * num_nodes + src] += weights[i];
        }
        
        let mut degree = vec![0.0f64; num_nodes];
        for i in 0..num_nodes {
            for j in 0..num_nodes {
                degree[i] += adjacency_matrix[i * num_nodes + j];
            }
        }
        
        let mut laplacian = vec![0.0f32; num_nodes * num_nodes];
        
        for i in 0..num_nodes{
            laplacian[i*num_nodes + i] += degree[i] - adjacency_matrix[i*num_nodes + i];
            
            for j in 0..num_nodes {
                if i != j{
                    laplacian[i*num_nodes + j] += adjacency_matrix[i*num_nodes + j];
                }
            }
        }
        
        if normalized {
            for i in 0..num_nodes {
                let deg_sqrt = degree[i].sqrt();
                if deg_sqrt > 0.0 {
                    for j in 0..num_nodes {
                        laplacian[i * num_nodes + j] /= deg_sqrt * degree[j].sqrt();
                    }
                }
            }
        }

        Tensor::from_data(laplacian, &[num_nodes, num_nodes])
    }
    
    impl GraphOps for Graph{
        
        fn add_node(&mut self , mut node : Node) -> Result<() , GraphError>{
            if node.id == 0 {
                node.id = self.next_node_id;
                self.next_node_id += 1;
            }
    
            // Update node type index
            self.node_types.entry(node.node_type.clone())
                .or_default()
                .push(node.id);
    
            self.nodes.insert(node.id, node);
            self.adjacency_list.entry(node.id).or_default();
            self.reverse_adjacency.entry(node.id).or_default();
            
            Ok(())
        }
        
        fn add_edge(&mut self, src: u32, dst: u32) -> Result<(), GraphError> {
            if !self.nodes.contains_key(&src) || !self.nodes.contains_key(&dst) {
                return Err(GraphError::NodeNotFound);
            }
    
            self.adjacency_list.get_mut(&src).unwrap().push(dst);
            self.reverse_adjacency.get_mut(&dst).unwrap().push(src);
            
            Ok(())
        }
    }
    
    pub fn add_edge(&mut self , edge : Edge) -> Result<() , GraphError>{
        
        if !self.nodes.contains_key(&edge.src) || !self.nodes.contains_key(&edge.dst) {
            return Err(GraphError::NodeNotFound);
        }
    
        self.adjacency_list.get_mut(&edge.src).unwrap().push(edge.dst);
        self.reverse_adjacency.get_mut(&edge.dst).unwrap().push(edge.src);
        
        if !self.is_directed && edge.source != edge.target {
            self.adjacency_list.entry(edge.target)
                .or_default()
                .push(edge.id);
            self.reverse_adjacency.entry(edge.source)
                .or_default()
                .push(edge.id);
        }

        // Update edge type index
        self.edge_types.entry(edge.edge_type.clone())
            .or_default()
            .push(edge.id);

        self.edges.insert(edge.id, edge);
        Ok(())
    }
    
    pub fn remove_node(&mut self , node_id : NodeID , edge_id : EdgeID) -> Result<Node , GraphError>{
        let node = self.nodes.remove(&node_id).ok_or(GraphError::NodeNotFound)?; 
        
        let mut edges_to_remove = Vec::new();
        
        if let Some(outgoing) = self.adjacency_list.remove(&node_id) {
            edges_to_remove.extend(outgoing);
        }
        
        if let Some(incoming) = self.reverse_adjacency.remove(&node_id) {
            edges_to_remove.extend(incoming);
        }
        
        for edges in edges_to_remove{
            self.edges.remove(edge_id);
        }
        
        Ok(Node)
        
    }
    
    pub fn remove_edge(&mut self , edge_id : EdgeID) -> Result<Edge , GraphError> {
        let edge = self.edges.remove(&edge_id).ok_or(GraphError::EdgeNotFound)?;
        
        self.adjacency_list.get_mut(&edge.src).unwrap().retain(|&x| x != edge_id);
        self.reverse_adjacency.get_mut(&edge.dst).unwrap().retain(|&x| x != edge_id);
        
        self.edge_types.get_mut(&edge.edge_type).unwrap().retain(|&x| x != edge_id);
        
        if !self.is_directed && edge.source != edge.target {
            if let Some(adj_list) = self.adjacency_list.get_mut(&edge.target) {
                adj_list.retain(|&id| id != edge_id);
            }
            if let Some(rev_adj_list) = self.reverse_adjacency.get_mut(&edge.source) {
                rev_adj_list.retain(|&id| id != edge_id);
            }
        }

        // Remove from edge type index
        if let Some(type_list) = self.edge_types.get_mut(&edge.edge_type) {
            type_list.retain(|&id| id != edge_id);
            if type_list.is_empty() {
                self.edge_types.remove(&edge.edge_type);
            }
        }

        Ok(edge)
    }
    
    pub fn get_node(&self , node_id: NodeID) -> Result<Node , GraphError>{
        self.nodes.get(&node_id).ok_or(GraphError::NodeNotFound)
    }
    
    pub fn get_edge(&self , edge_id: EdgeID) -> Result<Edge , GraphError>{
        self.edges.get(&edge_id).ok_or(GraphError::EdgeNotFound)
    }
    
    fn neighbors(&self, node_id: NodeId, direction: EdgeDirection) -> Vec<NodeId> {
        let mut neighbors = Vec::new();

        match direction {
            EdgeDirection::Outgoing => {
                if let Some(edge_ids) = self.adjacency_list.get(&node_id) {
                    for &edge_id in edge_ids {
                        if let Some(edge) = self.edges.get(&edge_id) {
                            neighbors.push(edge.target);
                        }
                    }
                }
            }
            EdgeDirection::Incoming => {
                if let Some(edge_ids) = self.reverse_adjacency.get(&node_id) {
                    for &edge_id in edge_ids {
                        if let Some(edge) = self.edges.get(&edge_id) {
                            neighbors.push(edge.source);
                        }
                    }
                }
            }
            EdgeDirection::Both => {
                let mut neighbor_set = HashSet::new();
                
                if let Some(edge_ids) = self.adjacency_list.get(&node_id) {
                    for &edge_id in edge_ids {
                        if let Some(edge) = self.edges.get(&edge_id) {
                            neighbor_set.insert(edge.target);
                        }
                    }
                }
                
                if let Some(edge_ids) = self.reverse_adjacency.get(&node_id) {
                    for &edge_id in edge_ids {
                        if let Some(edge) = self.edges.get(&edge_id) {
                            neighbor_set.insert(edge.source);
                        }
                    }
                }
                
                neighbors.extend(neighbor_set);
            }
        }

        neighbors
    }

    fn node_count(&self) -> usize {
        self.nodes.len()
    }

    fn edge_count(&self) -> usize {
        self.edges.len()
    }
}


#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GraphBatch{
    pub graphs: Vec<Graph>,
    pub node_features: Tensor ,
    pub edge_features: Option<Tensor> ,
    pub edge_indices: Tensor ,
    pub edge_weights: Option<Tensor>, 
    pub batch_vertices: Option<Tensor>,
    pub ptr: Vec<usize>,
    pub edge_ptr: Vec<usize>,
}

impl GraphBatch{
    pub fn new() -> Self {
        GraphBatch{
            graphs: Vec::new(),
            node_features: Tensor::new(),
            edge_features: None,
            edge_indices: Tensor::new(),
            edge_weights: None,
            batch_vertices: None,
            ptr: Vec::new(),
            edge_ptr: Vec::new(),
        }
    }
    
    pub fn from_graphs(&self , graphs: Vec<Graph>) -> Self {
        let mut batch = GraphBatch::new();
        batch.graphs = graphs;
        batch.build_batch_tensors()?;
        batch
    }
    
    pub fn batch_size(&self) -> usize {
        self.graphs.len()
    }
    
    pub fn total_node(&self) -> usize {
        self.graphs.iter().map(|g| g.node_count()).sum()
    }
    
    pub fn total_edge(&self) -> usize {
        self.graphs.iter().map(|g| g.edge_count()).sum()
    }
    
    pub fn total_features(&self) -> usize {
        self.node_features.size(0)
    }
    
    fn build_batch_tensors(&mut self) -> Result<(), GraphError> {
        let mut all_node_features = Vec::new();
        let mut all_edge_indices = Vec::new();
        let mut all_edge_features = Vec::new();
        let mut all_edge_weights = Vec::new();
        
        let mut node_offset = 0;
        let mut edge_offset = 0;
        
        self.ptr.clear();
        self.edge_ptr.clear();
        self.batch_indices.clear();
        
        self.ptr.push(0);
        self.edge_ptr.push(0);
        self.batch_indices.push(0);

        for graph in &self.graphs {
            let (edge_index, edge_weight, edge_feat) = graph.to_coo()?;
            
            // Collect node features
            for node in graph.nodes.values() {
                if let Some(ref features) = node.features {
                    let feat_vec = features.to_vec()?;
                    all_node_features.extend(feat_vec);
                }
            }
            
            // Collect edge indices (offset by current node count)
            let edge_indices_vec = edge_index.to_vec()?;
            for chunk in edge_indices_vec.chunks(2) {
                all_edge_indices.push(chunk[0] + node_offset as f32);
                all_edge_indices.push(chunk[1] + node_offset as f32);
            }
            
            // Collect edge weights
            let weights = edge_weight.to_vec()?;
            all_edge_weights.extend(weights.clone());
            
            // Collect edge features if present
            if let Some(feat) = edge_feat {
                let feat_vec = feat.to_vec()?;
                all_edge_features.extend(feat_vec);
            }

            node_offset += graph.node_count();
            edge_offset += weights.len();
            
            self.ptr.push(node_offset);
            self.edge_ptr.push(edge_offset);
            self.batch_indices.push(node_offset);
        }

        // Build batch tensors
        if !all_node_features.is_empty() {
            let feature_dim = if !self.graphs.is_empty() && !self.graphs[0].nodes.is_empty() {
                self.graphs[0].nodes.values().next().unwrap()
                    .feature_dim().unwrap_or(1)
            } else { 1 };
            
            self.node_features = Tensor::from_data(
                all_node_features, 
                &[node_offset, feature_dim]
            )?;
        }

        if !all_edge_indices.is_empty() {
            self.edge_indices = Tensor::from_data(
                all_edge_indices,
                &[2, edge_offset]
            )?;
        }

        if !all_edge_weights.is_empty() {
            self.edge_weights = Some(Tensor::from_data(
                all_edge_weights,
                &[edge_offset]
            )?);
        }

        if !all_edge_features.is_empty() {
            // Assume single feature dimension for simplicity
            self.edge_features = Some(Tensor::from_data(
                all_edge_features,
                &[edge_offset, 1]
            )?);
        }

        Ok(())
    }
}

pub struct RWSE{
    pub embedding_dim : usize, 
    pub transition_matrix : Vec<Vec<f32>>,
    pub adjacency_matrix : Vec<Vec<f32>>,
    pub node_count : usize,
}

impl RWSE{
    pub fn new(embedding_dim: usize, transition_matrix: Vec<Vec<f32>>, adjacency_matrix: Vec<Vec<f32>>, node_count: usize, walk_length: usize) -> Self{
        Self{
            embedding_dim,
            transition_matrix,
            adjacency_matrix,
            node_count,
            walk_length
        }
    }
    
    pub fn comp_transition_matrix(adj_matrix : &[Vec<f64>]) -> Vec<Vec<f64>>{
        let n = adj_matrix.len();
        let mut transition_matrix =  vec![vec![0.0f64 ; n * n ]];
        
        for i in 0..n {
            let degree  = adj_matrix[i].iter().sum::<f64>();
            for j in 0..n {
                transition_matrix[i][j] = adj_matrix[i][j] / degree;
            }
        }
        
        transition_matrix
    } 
    
    fn matrix_power(&self, k: usize) -> Vec<Vec<f64>> {
        if k == 0 {
            // Return identity matrix
            let mut identity = vec![vec![0.0; self.node_count]; self.node_count];
            for i in 0..self.node_count {
                identity[i][i] = 1.0;
            }
            return identity;
        }
        
        if k == 1 {
            return self.transition_matrix.clone();
        }
        
        // Use repeated matrix multiplication
        let mut result = self.transition_matrix.clone();
        
        for _ in 2..=k {
            result = &result.matmul(&self.transition_matrix.t());
        }
        
        result
    }
}

pub struct LapPE{
    pub embedding_dim: usize,
    pub Laplacian_matrix: Vec<Vec<f64>>,
    pub node_count: usize,
}

impl LapPE{ 
    pub fn new(embedding_dim: usize, Laplacian_matrix: Vec<Vec<f64>>, node_count: usize) -> Self {
        LapPE {
            embedding_dim,
            Laplacian_matrix,
            node_count,
        }
    }
    
    
    pub fn compute_laplacian(adj_matrix : Vec<Vec<f64>> , normalized: bool) -> Vec<Vec<f64>>{
        let n = adj_matrix.len();
        let mut Laplacian_matrix = vec![vec![0.0f64;n*n]];
        let mut identity = vec![vec![0.0f64;n*n]];
        
        for i in 0..n{
            identity[i][i] = 1.0; 
        }
        
        for i in 0..n {
            let degree = adj_matrix[i].iter().sum::<f64>();
            for j in 0..n{
                if i == j {
                    Laplacian_matrix[i][j] = degree;
                }
                else{
                    Laplacian_matrix[i][j] = degree - adj_matrix[i][j];
                }
            }
            
            if normalized == true { 
                for j in 0..n {
                    Laplacian_matrix[i][j] = identity[i][j] - (sqrt(degree)) * (adj_matrix[i][j]) * (sqrt(degree));
                }
            }
            
            Laplacian_matrix 
        }
    }
    
    fn matrix_power(&self, k: usize) -> Vec<Vec<f64>> {
        if k == 0 {
            // Return identity matrix
            let mut identity = vec![vec![0.0; self.node_count]; self.node_count];
            for i in 0..self.node_count {
                identity[i][i] = 1.0;
            }
            return identity;
        }
        
        if k == 1 {
            return self.Laplacian_matrix.clone();
        }
        
        // Use repeated matrix multiplication
        let mut result = self.Laplacian_matrix.clone();
        
        for _ in 2..=k {
            result = &result.matmul(&self.Laplacian_matrix.t());
        }
        
        result
    }
}

pub fn adjacency_list_to_matrix(adj_list: &[Vec<usize>], n: Option<usize>) -> Vec<Vec<u8>> {
    let size = n.unwrap_or(adj_list.len());
    let mut matrix = vec![vec![0u8; size]; size];
    
    for (i, neighbors) in adj_list.iter().enumerate() {
        for &j in neighbors {
            if j < size {
                matrix[i][j] = 1;
            }
        }
    }
    
    matrix
    
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_adjacency_list_to_matrix() {
        let adj_list = vec![vec![1, 2], vec![0, 2], vec![0, 1]];
        let matrix = adjacency_list_to_matrix(&adj_list, None);
        assert_eq!(matrix, vec![vec![0, 1, 1], vec![1, 0, 1], vec![1, 1, 0]]);
    }

    #[test]
    fn test_matrix_power() {
        let graph = Graph::new(vec![vec![1, 2], vec![0, 2], vec![0, 1]]);
        let power = graph.matrix_power(2);
        assert_eq!(power, vec![vec![2, 2, 2], vec![2, 2, 2], vec![2, 2, 2]]);
    }
}

        