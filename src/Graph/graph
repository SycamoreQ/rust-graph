use std::sync::Arc;
use tensor::{Tensor , Device , Dtype , TensorError}
use serde::json;
use std::collections::{HashMap , HashSet}; 
use rayon::prelude::*;

pub type NodeID  = u64;
pub type EdgeID = u64;
pub type GraphID = u64 ; 
pub type SubgraphID = u64;


#[derive(Debug , Clone , PartialEq , HashMap , Eq)]
pub struct Node{
    pub id : NodeID,
    pub nodeType: Option<Tensor>,
    pub attributes : HashMap<String , AttributeValue>,
    pub features: Option<Tensor>,

}

impl Node {
    pub fn new(id : NodeID , node_type : Option<Tensor>) {
        Self(
            id ,
            node_type ,
            HashMap::new(),
            None,
        )
    }
    
    pub fn with_features(mut self, features: Tensor) -> Self {
        self.features = Some(features);
        self
    }

    pub fn with_attribute<V: Into<AttributeValue>>(mut self, key: String, value: V) -> Self {
        self.attributes.insert(key, value.into());
        self
    }

    pub fn feature_dim(&self) -> Option<usize> {
        self.features.as_ref().map(|f| f.shape()[f.shape().len() - 1])
    }
}


pub struct Edge{
    pub id: EdgeID,
    pub src: NodeID,
    pub dst: NodeID,
    pub EdgeType: Option<Tensor>,
    pub features: Option<Tensor>,
    pub weight: f32 , 
    pub attributes: HashMap<String , AttributeValue>,
}

impl Edge{ 
    pub fn new(id : EdgeID , src: NodeID , dst: NodeID ,  edge_type: Option<Tensor>){
        Self(
            id , 
            src ,
            dst ,
            edge_type,
            None,
            1.0,
            HashMap::new(),
        )   
    }
    
    pub fn with_features(mut self, features: Tensor) -> Self {
        self.features = Some(features);
        self
    }

    pub fn with_attribute<V: Into<AttributeValue>>(mut self, key: String, value: V) -> Self {
        self.attributes.insert(key, value.into());
        self
    }
    
    pub fn with_weight(mut self, weight: f32) -> Self {
        self.weight = weight;
        self
    }

    pub fn feature_dim(&self) -> Option<usize> {
        self.features.as_ref().map(|f| f.shape()[f.shape().len() - 1])
    }
    
    pub fn reverse(&self) -> Self {
        Edge {
            id: self.id,
            source: self.target,
            target: self.source,
            edge_type: self.edge_type.clone(),
            features: self.features.clone(),
            weight: self.weight,
            attributes: self.attributes.clone(),
        }
    }
}

#[derive(Debug, Clone)]
pub enum AttributeValue {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    Vector(Vec<f32>),
    Tensor(Tensor),
}

impl From<String> for AttributeValue {
    fn from(s: String) -> Self { AttributeValue::String(s) }
}
impl From<i64> for AttributeValue {
    fn from(i: i64) -> Self { AttributeValue::Integer(i) }
}
impl From<f64> for AttributeValue {
    fn from(f: f64) -> Self { AttributeValue::Float(f) }
}
impl From<bool> for AttributeValue {
    fn from(b: bool) -> Self { AttributeValue::Boolean(b) }
}
impl From<Vec<f32>> for AttributeValue {
    fn from(v: Vec<f32>) -> Self { AttributeValue::Vector(v) }
}

/// Error types for graph operations
#[derive(Debug)]
pub enum GraphError {
    NodeNotFound(NodeId),
    EdgeNotFound(EdgeId),
    InvalidEdge(String),
    FeatureMismatch(String),
    ConversionError(String),
    TensorError(TensorError),
}

impl From<TensorError> for GraphError {
    fn from(e: TensorError) -> Self {
        GraphError::TensorError(e)
    }
}

impl std::fmt::Display for GraphError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GraphError::NodeNotFound(id) => write!(f, "Node not found: {}", id),
            GraphError::EdgeNotFound(id) => write!(f, "Edge not found: {}", id),
            GraphError::InvalidEdge(msg) => write!(f, "Invalid edge: {}", msg),
            GraphError::FeatureMismatch(msg) => write!(f, "Feature mismatch: {}", msg),
            GraphError::ConversionError(msg) => write!(f, "Conversion error: {}", msg),
            GraphError::TensorError(e) => write!(f, "Tensor error: {}", e),
        }
    }
}

pub trait GraphOps{
    
    
}



